JWT Token Verification: Implement a middleware or interceptor that checks for the presence of a valid JWT token in the request headers. This middleware should be part of your main API service.

Token Issuance: When a user logs in through the authentication API, issue a JWT token as usual. The token should contain necessary claims such as user ID, roles, etc., which will be used for authorization later.

Token Storage: Store the issued JWT token securely on the client side (e.g., in memory, local storage, cookies). Ensure that tokens are sent with every subsequent request to the main API.

Communication Between Containers: If there's any direct communication between the two containers, ensure it's secured and only happens over internal networks. For example, if you need to validate a token against a list of revoked tokens, you could have a shared database or cache accessible by both services.

Load Balancer: Deploy a load balancer in front of your services to distribute incoming traffic. Configure the load balancer to route authentication requests to the authentication API container and other requests to the main API container.

Service Discovery: If you're using a microservices architecture, consider implementing service discovery so that your services can find and communicate with each other dynamically.

Security Measures: Ensure that all communication between containers and external clients is encrypted using HTTPS. Also, consider using network policies to restrict access between containers.

Monitoring and Logging: Set up monitoring and logging to track the performance and security of your services. This will help you identify and troubleshoot issues quickly.



# Define your JWT settings
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="auth/login")

class TokenData(BaseModel):
    username: str = None

def decode_jwt(token: str = Depends(oauth2_scheme)):
    try:
        payload = jwt.decode(token, "YOUR_SECRET_KEY", algorithms=["HS256"])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except JWTError:
        raise credentials_exception
    return token_data

app = FastAPI()

@app.middleware("http")
async def verify_token(request: Request, call_next):
    # Extract the token from the Authorization header
    auth_header = request.headers.get('Authorization')
    if not auth_header:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail='Not authenticated')
    
    # Decode and verify the token
    try:
        token_data = decode_jwt(auth_header)
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail='Invalid token')
    
    # Attach the token data to the request state
    request.state.token_data = token_data
    
    response = await call_next(request)
    return response

@app.get("/protected")
async def protected_route(token_data: TokenData = Depends(verify_token)):
    return {"message": f"Hello {token_data.username}"}


# Améliorations possibles
- Utiliser des cluster de containers, en utilisant Kube par exemple
- Restreindre les accès entre les containers (par exemple bdd1 <-> main_api mais pas bdd1 <-> auth_api)
- Rendre les communications entre containers sécurisées en HTTPS
- Ajouter un système de logging global, avec possiblement des metrics